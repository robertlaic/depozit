<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scanare Etichete - Depozit</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <style>
        @page {
            size: A4 landscape;
            margin: 0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 30px;
            backdrop-filter: blur(10px);
        }

        .header-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .logo-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .company-logo {
            height: 60px;
            width: auto;
        }

        h1 {
            color: #333;
            font-size: 2.2em;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            -webkit-text-fill-color: transparent;
            margin: 0;
        }

        .back-button {
            background: #f5f5f5;
            color: #333;
            border: 2px solid #e0e0e0;
            padding: 10px 20px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #e0e0e0;
            transform: translateY(-2px);
        }

        .scan-section {
            text-align: center;
            margin-bottom: 30px;
        }

        .scan-instructions {
            background: linear-gradient(135deg, #E8F5E8 0%, #F1F8E9 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            border-left: 4px solid #4CAF50;
        }

        .scan-instructions h3 {
            color: #2E7D32;
            margin-bottom: 10px;
        }

        .scan-instructions p {
            color: #388E3C;
            line-height: 1.6;
        }

        .data-counter {
            background: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            border-left: 4px solid #2196F3;
        }

        .counter-number {
            font-size: 24px;
            font-weight: bold;
            color: #1976D2;
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin: 25px 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-gryphon {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
            color: white;
        }

        .btn-gryphon:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 152, 0, 0.3);
        }

        .btn-scanner {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }

        .btn-scanner:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(76, 175, 80, 0.3);
        }

        .btn-send {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            font-size: 18px;
            padding: 15px 40px;
        }

        .btn-send:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(33, 150, 243, 0.3);
        }

        .btn-send:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-clear {
            background: #f44336;
            color: white;
        }

        .btn-clear:hover {
            background: #d32f2f;
            transform: translateY(-2px);
        }

        .scanned-data-section {
            margin-top: 30px;
        }

        .data-table-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            max-height: 500px;
            overflow-y: auto;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            table-layout: fixed;
        }

        .data-table th, .data-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
            font-size: 13px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .data-table th {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        /* Colorare alternativƒÉ pentru etichete */
        .data-table .label-group-odd {
            background-color: #f8f9fa;
        }

        .data-table .label-group-even {
            background-color: #e3f2fd;
        }

        .data-table .label-group-odd:hover {
            background-color: #e8f5e8;
        }

        .data-table .label-group-even:hover {
            background-color: #bbdefb;
        }

        /* Stiluri pentru celulele editabile */
        .editable-cell {
            cursor: pointer;
            position: relative;
        }

        .editable-cell:hover {
            background-color: #fffbf0 !important;
            border: 1px solid #ff9800;
        }

        .edit-input {
            width: 100%;
            padding: 4px;
            border: 2px solid #4CAF50;
            border-radius: 4px;
            font-size: 13px;
            background: white;
            text-align: center;
        }

        .edit-input:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 5px rgba(33, 150, 243, 0.3);
        }

        /* Column widths pentru tabel */
        .data-table th:nth-child(1), .data-table td:nth-child(1) { width: 200px; } /* Cod */
        .data-table th:nth-child(2), .data-table td:nth-child(2) { width: 80px; }  /* Tip */
        .data-table th:nth-child(3), .data-table td:nth-child(3) { width: 70px; }  /* Lungime */
        .data-table th:nth-child(4), .data-table td:nth-child(4) { width: 70px; }  /* LƒÉ»õime */
        .data-table th:nth-child(5), .data-table td:nth-child(5) { width: 70px; }  /* Grosime */
        .data-table th:nth-child(6), .data-table td:nth-child(6) { width: 70px; }  /* Nr. Buc */
        .data-table th:nth-child(7), .data-table td:nth-child(7) { width: 90px; }  /* Volum */
        .data-table th:nth-child(8), .data-table td:nth-child(8) { width: 80px; }  /* Calitate */
        .data-table th:nth-child(9), .data-table td:nth-child(9) { width: 80px; }  /* Data */
        .data-table th:nth-child(10), .data-table td:nth-child(10) { width: 80px; } /* Specia */
        .data-table th:nth-child(11), .data-table td:nth-child(11) { width: 100px; } /* Nume */
        .data-table th:nth-child(12), .data-table td:nth-child(12) { width: 80px; }  /* Loca»õie */
        .data-table th:nth-child(13), .data-table td:nth-child(13) { width: 60px; }  /* Ac»õiuni */

        .action-cell {
            text-align: center;
        }

        .btn-delete {
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-delete:hover {
            background: #cc0000;
            transform: scale(1.1);
        }

        .status-section {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
        }

        .status-ready {
            background: #E8F5E8;
            color: #2E7D32;
            border: 1px solid #4CAF50;
        }

        .status-processing {
            background: #FFF3E0;
            color: #F57C00;
            border: 1px solid #FF9800;
        }

        .status-success {
            background: #E3F2FD;
            color: #1976D2;
            border: 1px solid #2196F3;
        }

        .status-error {
            background: #FFEBEE;
            color: #D32F2F;
            border: 1px solid #F44336;
        }

        /* Modal styles - reused from original */
        .gryphon-container, .scanner-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
        }

        .gryphon-content, .scanner-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            text-align: center;
        }

        .gryphon-animation {
            width: 150px;
            height: 150px;
            margin: 0 auto 20px;
            background: linear-gradient(135deg, #FF9800, #F57C00);
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: gryphonPulse 1.5s infinite;
            font-size: 60px;
            color: white;
        }

        @keyframes gryphonPulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.7); }
            70% { transform: scale(1.1); box-shadow: 0 0 0 20px rgba(255, 152, 0, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 152, 0, 0); }
        }

        .scanner-video {
            width: 100%;
            height: 300px;
            border-radius: 10px;
            background: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            position: relative;
            overflow: hidden;
        }

        .scanner-video video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 10px;
        }

        .scanner-input {
            position: absolute;
            left: -9999px;
            opacity: 0;
            height: 1px;
            width: 1px;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4CAF50;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-weight: bold;
            z-index: 1001;
            display: none;
        }

        .notification.error {
            background: #ff4444;
        }

        .notification.warning {
            background: #FF9800;
        }

        @media (max-width: 768px) {
            .header-section {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }

            h1 {
                font-size: 1.8em;
            }

            .button-group {
                flex-direction: column;
                align-items: center;
            }

            .data-table {
                font-size: 11px;
            }

            .data-table th, .data-table td {
                padding: 6px 3px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-section">
            <div class="logo-container">
                <img src="ergio.png" alt="Ergio Logo" class="company-logo" onerror="this.style.display='none'">
                <h1>Scanare Etichete Depozit</h1>
            </div>
            <a href="index.html" class="back-button">‚Üê √énapoi la Meniu</a>
        </div>

        <div class="scan-section">
            <div class="scan-instructions">
                <h3>üìã Instruc»õiuni de Scanare</h3>
                <p>ScaneazƒÉ etichetele pentru a √Ænregistra datele √Æn Google Sheets. Datele pot fi editate prin click pe celule. Volumul se recalculeazƒÉ automat la editare.</p>
            </div>

            <div class="data-counter">
                <div>Etichete scanate √Æn aceastƒÉ sesiune:</div>
                <div class="counter-number" id="scan-counter">0</div>
            </div>

            <div class="button-group">
                <button class="btn-gryphon" onclick="startGryphonScanner()">
                    üî´ Scanner Gryphon <span style="font-size: 12px; opacity: 0.8;">[F8]</span>
                </button>
                <button class="btn-scanner" onclick="startCameraScanner()">üì± Camera</button>
                <button class="btn-send" id="send-btn" onclick="sendToGoogleSheets()" disabled>
                    üìä Trimite Date (0)
                </button>
                <button class="btn-clear" onclick="clearScannedData()">üóëÔ∏è »òterge Date</button>
            </div>

            <div class="status-section status-ready" id="status">
                ‚úÖ Sistem gata pentru scanare - ApasƒÉ unul din butoanele de scanare pentru a √Æncepe
            </div>
        </div>

        <div class="scanned-data-section">
            <div class="data-table-container">
                <h3>üìä Date Scanate (Click pe celule pentru editare)</h3>
                <table class="data-table" id="data-table">
                    <thead>
                        <tr>
                            <th>Cod</th>
                            <th>Tip</th>
                            <th>Lungime</th>
                            <th>LƒÉ»õime</th>
                            <th>Grosime</th>
                            <th>Nr. Buc</th>
                            <th>Volum</th>
                            <th>Calitate</th>
                            <th>Data</th>
                            <th>Specia</th>
                            <th>Nume</th>
                            <th>Loca»õie</th>
                            <th>Ac»õiuni</th>
                        </tr>
                    </thead>
                    <tbody id="data-tbody">
                        <tr>
                            <td colspan="13" style="text-align: center; color: #666; padding: 40px;">
                                Nu s-au scanat etichete √ÆncƒÉ. Folose»ôte scannerul pentru a adƒÉuga date.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Gryphon Scanner Modal -->
    <div class="gryphon-container" id="gryphon-container">
        <div class="gryphon-content">
            <h3 style="margin-bottom: 20px;">Scanner Datalogic Gryphon</h3>
            <div class="gryphon-animation">üî´</div>
            <div class="gryphon-status" id="gryphon-status">Scannerul este gata pentru scanare</div>
            <div class="gryphon-instructions">
                ‚Ä¢ Pozi»õioneazƒÉ scannerul deasupra QR-ului<br>
                ‚Ä¢ ApasƒÉ trigger-ul pentru a scana<br>
                ‚Ä¢ Pentru a anula, apasƒÉ ESC sau butonul de mai jos
            </div>
            <input 
                type="text" 
                id="scanner-input" 
                class="scanner-input" 
                autocomplete="off" 
                spellcheck="false" 
                autocorrect="off"
                autocapitalize="off"
                inputmode="none"
                enterkeyhint="done"
                aria-label="Intrare scanner Gryphon" 
            />
            <div style="margin-top: 30px;">
                <button class="btn-clear" onclick="stopGryphonScanner()">AnuleazƒÉ (ESC)</button>
            </div>
        </div>
    </div>

    <!-- Camera Scanner Modal -->
    <div class="scanner-container" id="scanner-container">
        <div class="scanner-content">
            <h3 style="text-align: center; margin-bottom: 20px;">ScaneazƒÉ Cod QR cu Camera</h3>
            <div id="scanner-video" class="scanner-video">
                <div class="status-message">Camera se √ÆncarcƒÉ...</div>
            </div>
            <div class="scanner-status" id="scanner-status">Pozi»õioneazƒÉ codul QR √Æn fa»õa camerei</div>
            <div class="scanner-controls" style="margin-top: 20px;">
                <button class="btn-clear" onclick="stopCameraScanner()">AnuleazƒÉ</button>
                <button class="btn-scanner" onclick="switchCamera()" id="switch-camera">SchimbƒÉ Camera</button>
            </div>
        </div>
    </div>

    <div class="notification" id="notification"></div>

    <script>
        // Global variables
        let scannedData = [];
        let scannedLabelsCount = 0;
        let labelGroupColors = []; // Pentru colorarea alternativƒÉ a etichetelor
        let gryphonActive = false;
        let mediaStream = null;
        let currentCamera = 'environment';

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            updateCounter();
            showNotification('Sistem de scanare √ÆncƒÉrcat cu succes! üöÄ');
            
            // Add keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                if (e.key === 'F8' && !gryphonActive) {
                    e.preventDefault();
                    startGryphonScanner();
                }
                if (e.key === 'Escape') {
                    stopCameraScanner();
                    stopGryphonScanner();
                }
            });
        });

        // Calculate volume with 4 decimals: V = nr.buc * (L * l * G) / 10^9
        function calculateVolume(lungime, latime, grosime, nr_buc = 1) {
            const L = parseFloat(lungime) || 0;
            const l = parseFloat(latime) || 0;
            const G = parseFloat(grosime) || 0;
            const buc = parseFloat(nr_buc) || 1;
            
            // Calcul √Æn m¬≥: V = nr.buc * (L * l * G) / 10^9
            const volum = (buc * L * l * G) / 1000000000;
            return parseFloat(volum.toFixed(4));
        }

        // Format volume for display (with comma as decimal separator for Romanian locale)
        function formatVolumeForDisplay(volume) {
            return volume.toFixed(4).replace('.', ',');
        }

        // Format volume for Google Sheets (with comma as decimal separator for Romanian locale)
        function formatVolumeForGoogleSheets(volume) {
            return volume.toFixed(4).replace('.', ',');
        }

        // Make cell editable
        function makeEditable(cell, rowIndex, columnName, originalValue) {
            if (cell.querySelector('.edit-input')) return; // Already editing
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'edit-input';
            input.value = originalValue;
            
            cell.innerHTML = '';
            cell.appendChild(input);
            input.focus();
            input.select();
            
            const saveEdit = () => {
                const newValue = input.value.trim();
                
                if (newValue === '') {
                    showNotification('Valoarea nu poate fi goalƒÉ!', 'error');
                    input.focus();
                    return;
                }
                
                // Update data
                scannedData[rowIndex][columnName] = columnName === 'lungime' || columnName === 'latime' || 
                                                   columnName === 'grosime' || columnName === 'nr_buc' 
                                                   ? parseInt(newValue) || originalValue 
                                                   : newValue;
                
                // Recalculate volume ALWAYS when any numeric field changes
                if (['lungime', 'latime', 'grosime', 'nr_buc'].includes(columnName)) {
                    const entry = scannedData[rowIndex];
                    // IMPORTANT: Include nr_buc in volume calculation
                    entry.volum = calculateVolume(entry.lungime, entry.latime, entry.grosime, entry.nr_buc);
                    
                    // Update code if dimensions changed (not for quantity)
                    if (['lungime', 'latime', 'grosime'].includes(columnName)) {
                        entry.cod = `${entry.specia}_${entry.tip}_${entry.nume}_${entry.calitate}_${entry.lungime}x${entry.latime}x${entry.grosime}`;
                    }
                }
                
                refreshTable();
                showNotification('Date actualizate cu succes! ‚úì');
            };
            
            const cancelEdit = () => {
                refreshTable();
            };
            
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveEdit();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelEdit();
                }
            });
        }

        // Delete row
        function deleteRow(rowIndex) {
            if (confirm('E»ôti sigur cƒÉ vrei sƒÉ »ôtergi acest r√¢nd?')) {
                scannedData.splice(rowIndex, 1);
                
                // DacƒÉ s-a »ôters ultimul r√¢nd dintr-o etichetƒÉ, decrementeazƒÉ contorul
                // (Pentru simplitate, nu verificƒÉm exact - utilizatorul poate verifica vizual)
                
                refreshTable();
                updateCounter();
                showNotification('R√¢nd »ôters cu succes!');
            }
        }

        // Refresh table display
        function refreshTable() {
            const tbody = document.getElementById('data-tbody');
            
            if (scannedData.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="13" style="text-align: center; color: #666; padding: 40px;">
                            Nu s-au scanat etichete √ÆncƒÉ. Folose»ôte scannerul pentru a adƒÉuga date.
                        </td>
                    </tr>
                `;
                return;
            }
            
            tbody.innerHTML = '';
            
            scannedData.forEach((entry, index) => {
                const row = document.createElement('tr');
                
                // DeterminƒÉ clasa pentru colorarea alternativƒÉ
                const labelGroupIndex = labelGroupColors[index] || 0;
                const groupClass = labelGroupIndex % 2 === 0 ? 'label-group-even' : 'label-group-odd';
                row.className = groupClass;
                
                row.innerHTML = `
                <td class="editable-cell" title="${entry.cod}" onclick="makeEditable(this, ${index}, 'cod', '${entry.cod}')">${entry.cod.length > 25 ? entry.cod.substring(0, 25) + '...' : entry.cod}</td>
                    <td class="editable-cell" onclick="makeEditable(this, ${index}, 'tip', '${entry.tip}')">${entry.tip}</td>
                    <td class="editable-cell" onclick="makeEditable(this, ${index}, 'lungime', '${entry.lungime}')">${entry.lungime}</td>
                    <td class="${entry.tip === 'DIV' ? '' : 'editable-cell'}" ${entry.tip === 'DIV' ? '' : `onclick="makeEditable(this, ${index}, 'latime', '${entry.latime}')"`}>${entry.latime}</td>
                    <td class="editable-cell" onclick="makeEditable(this, ${index}, 'grosime', '${entry.grosime}')">${entry.grosime}</td>
                    <td class="${entry.tip === 'DIV' ? '' : 'editable-cell'}" ${entry.tip === 'DIV' ? '' : `onclick="makeEditable(this, ${index}, 'nr_buc', '${entry.nr_buc}')"`}>${entry.nr_buc}</td>
                    <td title="Volum: ${formatVolumeForDisplay(entry.volum)} m¬≥">${formatVolumeForDisplay(entry.volum)}</td>
                    <td class="editable-cell" onclick="makeEditable(this, ${index}, 'calitate', '${entry.calitate}')">${entry.calitate}</td>
                    <td class="editable-cell" onclick="makeEditable(this, ${index}, 'data', '${entry.data}')">${entry.data}</td>
                    <td class="editable-cell" onclick="makeEditable(this, ${index}, 'specia', '${entry.specia}')">${entry.specia}</td>
                    <td class="editable-cell" onclick="makeEditable(this, ${index}, 'nume', '${entry.nume}')" title="${entry.nume}">${entry.nume.length > 12 ? entry.nume.substring(0, 12) + '...' : entry.nume}</td>
                    <td class="editable-cell" onclick="makeEditable(this, ${index}, 'locatie', '${entry.locatie}')">${entry.locatie}</td>
                    <td class="action-cell">
                        <button class="btn-delete" onclick="deleteRow(${index})" title="»òterge r√¢ndul">‚úó</button>
                    </td>
                `;
                
                tbody.appendChild(row);
            });
        }

        // Update scan counter and send button
        function updateCounter() {
            const counter = document.getElementById('scan-counter');
            const sendBtn = document.getElementById('send-btn');
            const rowCount = scannedData.length;
            
            counter.textContent = scannedLabelsCount;
            sendBtn.textContent = `üìä Trimite Date (${rowCount} r√¢nduri)`;
            sendBtn.disabled = rowCount === 0;
        }

        // Process QR data for Google Sheets format
        function processQRForSheets(qrData) {
            console.log('Processing QR for Sheets:', qrData);
            
            // Clean the data
            let cleanedData = qrData
                .replace(/√Ç/g, '|')
                .replace(/\s+\|\s+/g, '|')
                .replace(/\s+\|\s*/g, '|')
                .replace(/\s*\|\s+/g, '|')
                .trim();
            
            const lines = cleanedData.split('\n').filter(line => line.trim() !== '');
            if (lines.length === 0) {
                throw new Error('Date QR goale dupƒÉ curƒÉ»õare');
            }
            
            const mainLine = lines[0];
            const parts = mainLine.split('|');
            
            if (parts.length < 3) {
                throw new Error('Format QR invalid: sunt necesare minim cod produs, dimensiune »ôi bucƒÉ»õi');
            }
            
            const productCode = parts[0].trim();
            const mainDimension = parts[1].trim();
            const mainQuantity = parts[2].trim();
            
            // Parse product code
            const productParts = productCode.split('_').filter(p => p.length > 0);
            if (productParts.length < 3) {
                throw new Error('Format cod produs insuficient');
            }
            
            const specia = productParts[0];
            const tip = productParts[1];
            const calitate = productParts[productParts.length - 1];
            const numeParts = productParts.slice(2, -1);
            const nume = numeParts.length > 0 ? numeParts.join('_') : productParts[2];
            
            // Parse main dimension
            const dimensionMatch = mainDimension.match(/(\d+)x(\d+)x(\d+)$/);
            if (!dimensionMatch) {
                throw new Error('Format dimensiune invalid');
            }
            
            const [, lungime, latime, grosime] = dimensionMatch;
            // Pentru DIV, mainQuantity reprezintƒÉ volumul, nu bucƒÉ»õile
                    let volum = 0;
                    let nrBuc = 0;

                    if (tip === 'DIV') {
                        // Pentru DIV, al treilea parametru din QR este volumul (cu punct ca separator)
                        volum = parseFloat(mainQuantity.replace(',', '.')) || 0;
                        nrBuc = ''; // LƒÉsƒÉm gol pentru DIV
                    } else {
                        // Pentru restul, calculƒÉm volumul normal
                        nrBuc = parseInt(mainQuantity) || 0;
                        volum = calculateVolume(lungime, latime, grosime, nrBuc);
                    }
            
            // // Calculate volume with 4 decimals: V = nr.buc * (L * l * G) / 10^9
            // const volum = calculateVolume(lungime, latime, grosime, mainQuantity);
            
            // Extract location if present
            let locatie = '';
            const lastPart = parts[parts.length - 1];
            const locationMatch = lastPart.match(/([A-G])-(\d+)-(\d+)$/);
            if (locationMatch) {
                locatie = lastPart;
            }
            
            // Current date
            const currentDate = new Date().toLocaleDateString('ro-RO');
                      
            // Create main entry
            const mainEntry = {
                cod: `${specia}_${tip}_${nume}_${calitate}_${lungime}x${latime}x${grosime}`,
                tip: tip,
                lungime: parseInt(lungime),
                latime: tip === 'DIV' ? '' : parseInt(latime), // Gol pentru DIV
                grosime: parseInt(grosime),
                nr_buc: tip === 'DIV' ? '' : nrBuc, // Gol pentru DIV
                volum: volum, // Pentru DIV este valoarea directƒÉ, pentru restul calculatƒÉ
                calitate: calitate,
                furnizor: '',
                data: currentDate,
                id_prod: '',
                specia: specia,
                nume: nume,
                bon_consum: '',
                locatie: locatie
            };
            
            const entries = [mainEntry];
            
            // Process additional dimensions if present
            // Pentru DIV nu procesƒÉm dimensiuni adi»õionale
        if (tip !== 'DIV') {
            for (let i = 3; i < parts.length - 1; i += 2) {
                if (i + 1 < parts.length) {
                    const dimPart = parts[i].trim();
                    const qtyPart = parts[i + 1].trim();
                    
                    const addDimMatch = dimPart.match(/(\d+)x(\d+)x(\d+)$/);
                    if (addDimMatch && !isNaN(qtyPart)) {
                        const [, L, l, G] = addDimMatch;
                        const addVolum = calculateVolume(L, l, G, qtyPart);
                        
                        const additionalEntry = {
                            cod: `${specia}_${tip}_${nume}_${calitate}_${L}x${l}x${G}`,
                            tip: tip,
                            lungime: parseInt(L),
                            latime: parseInt(l),
                            grosime: parseInt(G),
                            nr_buc: parseInt(qtyPart),
                            volum: addVolum,
                            calitate: calitate,
                            furnizor: '',
                            data: currentDate,
                            id_prod: '',
                            specia: specia,
                            nume: nume,
                            bon_consum: '',
                            locatie: locatie
                        };
                        
                        entries.push(additionalEntry);
                    }
                }
            }
            
            return entries;
        }
    }
        // Add scanned data to table with color grouping
        function addScannedDataToTable(entries) {
            const tbody = document.getElementById('data-tbody');
            
            // Clear empty message if present
            if (tbody.children.length === 1 && tbody.children[0].children.length === 1) {
                tbody.innerHTML = '';
            }
            
            // Assign group color for this label (alternating)
            const currentGroupColor = scannedLabelsCount % 2;
            
            entries.forEach(entry => {
                const currentIndex = scannedData.length;
                labelGroupColors[currentIndex] = currentGroupColor;
                scannedData.push(entry);
            });
            
            // Increment label count
            scannedLabelsCount++;
            
            refreshTable();
            updateCounter();
            updateStatus(`‚úÖ EtichetƒÉ scanatƒÉ! R√¢nduri adƒÉugate: ${entries.length}. Total: ${scannedData.length} r√¢nduri`, 'success');
        }

        // Clear scanned data
        function clearScannedData() {
            if (scannedData.length === 0) {
                showNotification('Nu existƒÉ date de »ôters!', 'warning');
                return;
            }
            
            if (confirm(`E»ôti sigur cƒÉ vrei sƒÉ »ôtergi toate datele (${scannedLabelsCount} etichete, ${scannedData.length} r√¢nduri)?`)) {
                scannedData = [];
                scannedLabelsCount = 0;
                labelGroupColors = [];
                refreshTable();
                updateCounter();
                updateStatus('üóëÔ∏è Toate datele au fost »ôterse', 'ready');
                showNotification('Date »ôterse cu succes!');
            }
        }

        // Send data to Google Sheets - IMPROVED VERSION with comma to dot conversion
        async function sendToGoogleSheets() {
            if (scannedData.length === 0) {
                showNotification('Nu existƒÉ date de trimis!', 'error');
                return;
            }
            
            updateStatus('üì§ Se trimit datele cƒÉtre Google Sheets...', 'processing');
            
            try {
                const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbz7jLGhBtrJ0xn1OQ5smMEppY-zwqew1GSO6UWSJw9nWlvnMV1Y4lGTgtELtlDcW3g/exec';
                const SPREADSHEET_ID = '10TegZTOq45WtGol7KftrJm080PbB7pwDEv92fnq9BXw';
                const SHEET_ID = '39202919';
                
                console.log('Trimitere date cƒÉtre Google Sheets:', scannedData);
                
                // Format data for Google Sheets with proper volume format
                const formattedData = scannedData.map(row => ({
                    cod: row.cod || '',
                    tip: row.tip || '',
                    lungime: parseInt(row.lungime) || 0,
                    latime: parseInt(row.latime) || 0,
                    grosime: parseInt(row.grosime) || 0,
                    nr_buc: parseInt(row.nr_buc) || 0,
                    volum: formatVolumeForGoogleSheets(row.volum), // Convert to comma decimal for Romanian Google Sheets
                    calitate: row.calitate || '',
                    furnizor: '',
                    data: row.data || new Date().toLocaleDateString('ro-RO'),
                    id_prod: '',
                    specia: row.specia || '',
                    nume: row.nume || '',
                    bon_consum: '',
                    locatie: row.locatie || ''
                }));
                
                console.log('Date formatate pentru Google Sheets (4 zecimale cu virgulƒÉ):', formattedData);
                
                // Convert to array format for Google Sheets API
                const sheetsData = formattedData.map(row => [
                    row.cod,        // A - Cod
                    row.tip,        // B - TIP
                    row.lungime,    // C - LUNGIME
                    row.latime,     // D - LATIME
                    row.grosime,    // E - GROSIME
                    row.nr_buc,     // F - NR.BUC
                    row.volum,      // G - VOLUM (4 zecimale cu virgulƒÉ!)
                    row.calitate,   // H - CALITATE
                    row.furnizor,   // I - FURNIZOR (gol)
                    row.data,       // J - DATA
                    row.id_prod,    // K - ID_PROD (gol)
                    row.specia,     // L - SPECIA
                    row.nume,       // M - NUME
                    row.bon_consum, // N - BON CONSUM (gol)
                    row.locatie     // O - LOCATIE
                ]);
                
                // Log pentru verificare format volum
                console.log('Exemple volume formatate pentru Google Sheets (4 zecimale cu virgulƒÉ):');
                sheetsData.slice(0, 3).forEach((row, index) => {
                    console.log(`R√¢nd ${index + 1} - Volum: "${row[6]}" (tip: ${typeof row[6]})`);
                });
                
                // Prepare request data
                const requestData = {
                    action: 'appendRows',
                    spreadsheetId: SPREADSHEET_ID,
                    sheetId: SHEET_ID,
                    values: sheetsData,
                    timestamp: new Date().toISOString(),
                    metadata: {
                        labelsScanned: scannedLabelsCount,
                        rowsTotal: scannedData.length,
                        locale: 'ro-RO',
                        decimalSeparator: ',',
                        decimals: 4
                    }
                };
                
                console.log('Request data pentru Google Apps Script:', requestData);
                
                // Try multiple methods to avoid CORS issues
                let response;
                const maxAttempts = 3;
                
                for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                    try {
                        console.log(`√éncercare ${attempt}/${maxAttempts} de trimitere cƒÉtre Google Apps Script...`);
                        
                        if (attempt === 1) {
                            response = await fetch(SCRIPT_URL, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'text/plain;charset=utf-8',
                                },
                                body: JSON.stringify(requestData),
                                mode: 'no-cors',
                                cache: 'no-cache'
                            });
                            
                            if (response.type === 'opaque') {
                                console.log('Request trimis cu no-cors - presupunem succes');
                                break;
                            }
                        } else if (attempt === 2) {
                            response = await fetch(SCRIPT_URL, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify(requestData),
                                mode: 'cors',
                                cache: 'no-cache'
                            });
                        } else {
                            const urlParams = new URLSearchParams({
                                action: 'appendRows',
                                data: JSON.stringify(requestData)
                            });
                            
                            response = await fetch(`${SCRIPT_URL}?${urlParams}`, {
                                method: 'GET',
                                mode: 'cors',
                                cache: 'no-cache'
                            });
                        }
                        
                        console.log(`√éncercare ${attempt} - Response status:`, response.status);
                        break;
                        
                    } catch (fetchError) {
                        console.error(`√éncercare ${attempt} e»ôuatƒÉ:`, fetchError);
                        
                        if (attempt === maxAttempts) {
                            throw fetchError;
                        }
                        
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }
                
                // Process response if available
                if (response && response.type !== 'opaque') {
                    console.log('Response headers:', [...response.headers.entries()]);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                    }
                    
                    const result = await response.text();
                    console.log('RƒÉspuns de la Google Apps Script:', result);
                    
                    try {
                        const jsonResult = JSON.parse(result);
                        
                        if (jsonResult.status === 'success' || jsonResult.success === true) {
                            console.log('Succes confirmat de server:', jsonResult);
                        } else {
                            throw new Error(jsonResult.message || jsonResult.error || 'Eroare returnatƒÉ de server');
                        }
                    } catch (parseError) {
                        console.log('Nu s-a putut parsa JSON, dar presupunem succes');
                    }
                }
                
                // Show success
                updateStatus(`‚úÖ ${scannedLabelsCount} etichete (${scannedData.length} r√¢nduri) trimise cu succes √Æn Google Sheets!`, 'success');
                showNotification(`${scannedLabelsCount} etichete (${scannedData.length} r√¢nduri) trimise cu succes! üéâ`);
                
                // Clear data after successful upload
                setTimeout(() => {
                    clearScannedData();
                    updateStatus('‚úÖ Sistem gata pentru scanare - ApasƒÉ unul din butoanele de scanare pentru a √Æncepe', 'ready');
                }, 2000);
                
            } catch (error) {
                console.error('Eroare detaliatƒÉ la trimiterea √Æn Google Sheets:', error);
                
                // For local CORS issues, use simulation
                if (error.message.includes('Failed to fetch') && window.location.protocol === 'file:') {
                    console.warn('Folosim simularea din cauza restric»õiilor locale');
                    try {
                        await simulateGoogleSheetsUpload();
                        updateStatus(`‚úÖ ${scannedLabelsCount} etichete (${scannedData.length} r√¢nduri) trimise cu succes (simulare)!`, 'success');
                        showNotification(`${scannedLabelsCount} etichete trimise cu succes! üéâ (simulare)`);
                        
                        setTimeout(() => {
                            clearScannedData();
                            updateStatus('‚úÖ Sistem gata pentru scanare - ApasƒÉ unul din butoanele de scanare pentru a √Æncepe', 'ready');
                        }, 2000);
                        return;
                    } catch (simError) {
                        console.error('Eroare »ôi la simulare:', simError);
                    }
                }
                
                // Improved error messages
                let userMessage = 'Eroare la trimiterea datelor √Æn Google Sheets';
                
                if (error.message.includes('Failed to fetch')) {
                    userMessage = 'Nu s-a putut conecta la Google Apps Script. VerificƒÉ conexiunea la internet.';
                } else if (error.message.includes('CORS')) {
                    userMessage = 'ProblemƒÉ CORS. Google Apps Script trebuie sƒÉ fie deployed corect.';
                } else if (error.message.includes('HTTP error')) {
                    userMessage = 'Eroare de server. Google Apps Script poate fi indisponibil temporar.';
                } else if (error.message.length > 10) {
                    userMessage = error.message;
                }
                
                updateStatus('‚ùå Eroare la trimiterea datelor. √éncearcƒÉ din nou.', 'error');
                showNotification(userMessage, 'error');
                
                console.error('Detalii eroare pentru debugging:', {
                    message: error.message,
                    stack: error.stack,
                    scannedLabelsCount: scannedLabelsCount,
                    scannedDataCount: scannedData.length,
                    timestamp: new Date().toISOString()
                });
            }
        }

        // Improved simulation function
        function simulateGoogleSheetsUpload() {
            return new Promise((resolve, reject) => {
                console.log('üìã SIMULARE: Procesez datele pentru Google Sheets...');
                console.log(`üìä Etichete scanate: ${scannedLabelsCount}`);
                console.log(`üìä Total r√¢nduri: ${scannedData.length}`);
                
                // Show data that would be sent with proper volume format: V = nr.buc * (L*l*G)/10^9
                const formattedData = scannedData.map(row => [
                    row.cod, row.tip, row.lungime, row.latime, row.grosime,
                    row.nr_buc, formatVolumeForGoogleSheets(row.volum), row.calitate, '',
                    row.data, '', row.specia, row.nume, '', row.locatie
                ]);
                
                console.table(formattedData);
                console.log('üîç Verificare format volum (V = nr.buc √ó (L√ól√óG)/10^9 cu virgulƒÉ - primele 3 r√¢nduri):');
                formattedData.slice(0, 3).forEach((row, index) => {
                    console.log(`R√¢nd ${index + 1} - Volum: "${row[6]}" (tip: ${typeof row[6]})`);
                });
                
                // Simulate network delay
                setTimeout(() => {
                    if (Math.random() > 0.02) { // 98% success rate
                        resolve({
                            success: true,
                            message: `Date simulate trimise cu succes (${scannedLabelsCount} etichete, ${formattedData.length} r√¢nduri)`,
                            labelsScanned: scannedLabelsCount,
                            rowsAdded: formattedData.length
                        });
                    } else {
                        reject(new Error('Eroare de re»õea simulatƒÉ (2% din timp)'));
                    }
                }, 1500);
            });
        }

        // Update status message
        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status-section status-${type}`;
        }

        // Show notification
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        // Gryphon Scanner Functions
        function startGryphonScanner() {
            if (gryphonActive) return;
            
            gryphonActive = true;
            const gryphonContainer = document.getElementById('gryphon-container');
            const scannerInput = document.getElementById('scanner-input');
            
            gryphonContainer.style.display = 'block';
            
            setTimeout(() => {
                scannerInput.focus();
                scannerInput.value = '';
            }, 100);
            
            const inputHandler = function(event) {
                if (!gryphonActive) return;
                
                const scannedQR = event.target.value.trim();
                
                if (scannedQR.length > 10) {
                    document.getElementById('gryphon-status').textContent = 'Date primite... Procesare...';
                    
                    setTimeout(() => {
                        if (scannedQR.length > 0 && gryphonActive) {
                            try {
                                const entries = processQRForSheets(scannedQR);
                                addScannedDataToTable(entries);
                                stopGryphonScanner();
                                showNotification(`EtichetƒÉ scanatƒÉ cu succes! ${entries.length} r√¢nduri adƒÉugate üéâ`);
                            } catch (error) {
                                console.error('Error processing QR:', error);
                                showNotification(`Eroare procesare: ${error.message}`, 'error');
                                document.getElementById('gryphon-status').textContent = 'Eroare parsare - √ÆncearcƒÉ din nou';
                            }
                            scannerInput.value = '';
                        }
                    }, 200);
                }
            };
            
            const keydownHandler = function(event) {
                if (!gryphonActive) return;
                
                if (event.key === 'Enter') {
                    event.preventDefault();
                    
                    const scannedQR = scannerInput.value.trim();
                    
                    if (scannedQR) {
                        try {
                            const entries = processQRForSheets(scannedQR);
                            addScannedDataToTable(entries);
                            stopGryphonScanner();
                            showNotification(`EtichetƒÉ scanatƒÉ cu succes! ${entries.length} r√¢nduri adƒÉugate üéâ`);
                        } catch (error) {
                            console.error('Error processing QR:', error);
                            showNotification(`Eroare procesare: ${error.message}`, 'error');
                        }
                    } else {
                        showNotification('Nu s-au detectat date. √éncearcƒÉ din nou.', 'error');
                    }
                    
                    scannerInput.value = '';
                    return false;
                }
            };
            
            scannerInput.addEventListener('input', inputHandler);
            scannerInput.addEventListener('keydown', keydownHandler);
            
            document.getElementById('gryphon-status').textContent = 'Scanner activ - ScaneazƒÉ QR-ul acum!';
            updateStatus('üî´ Scanner Gryphon activ - ScaneazƒÉ o etichetƒÉ', 'processing');
        }

        function stopGryphonScanner() {
            gryphonActive = false;
            const gryphonContainer = document.getElementById('gryphon-container');
            gryphonContainer.style.display = 'none';
            updateStatus('‚úÖ Sistem gata pentru scanare - ApasƒÉ unul din butoanele de scanare pentru a √Æncepe', 'ready');
        }

        // Camera Scanner Functions
        async function startCameraScanner() {
            const scannerContainer = document.getElementById('scanner-container');
            const videoElement = document.getElementById('scanner-video');
            
            scannerContainer.style.display = 'block';
            videoElement.innerHTML = '<div style="padding: 20px;">Se √ÆncarcƒÉ camera...</div>';
            updateStatus('üì± Camera se √ÆncarcƒÉ...', 'processing');
            
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: currentCamera,
                        width: { ideal: 1280, min: 640 },
                        height: { ideal: 720, min: 480 }
                    }
                });
                
                const video = document.createElement('video');
                video.srcObject = mediaStream;
                video.setAttribute('playsinline', true);
                video.play();
                
                videoElement.innerHTML = '';
                videoElement.appendChild(video);
                
                document.getElementById('scanner-status').textContent = 'Pozi»õioneazƒÉ QR-ul √Æn fa»õa camerei';
                updateStatus('üì± Camera activƒÉ - ScaneazƒÉ o etichetƒÉ', 'processing');
                
                video.addEventListener('loadedmetadata', () => {
                    startQRDetection(video);
                });
                
            } catch (error) {
                console.error('Camera error:', error);
                let errorMessage = 'Nu s-a putut accesa camera!';
                
                if (error.name === 'NotAllowedError') {
                    errorMessage = 'Acces la camerƒÉ refuzat!';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = 'Nu s-a gƒÉsit nicio camerƒÉ!';
                }
                
                videoElement.innerHTML = `<div style="padding: 20px; color: red;">${errorMessage}</div>`;
                showNotification(errorMessage, 'error');
                updateStatus('‚ùå Eroare camerƒÉ', 'error');
            }
        }

        function startQRDetection(video) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            let isScanning = true;
            
            function scanFrame() {
                if (!isScanning || !video.videoWidth || !video.videoHeight) {
                    if (isScanning) {
                        requestAnimationFrame(scanFrame);
                    }
                    return;
                }
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const code = jsQR(imageData.data, imageData.width, imageData.height);
                
                if (code) {
                    isScanning = false;
                    
                    try {
                        const entries = processQRForSheets(code.data);
                        addScannedDataToTable(entries);
                        stopCameraScanner();
                        showNotification(`EtichetƒÉ scanatƒÉ cu succes! ${entries.length} r√¢nduri adƒÉugate üéâ`);
                    } catch (error) {
                        console.error('Error processing QR:', error);
                        showNotification(`Eroare procesare: ${error.message}`, 'error');
                        isScanning = true;
                        requestAnimationFrame(scanFrame);
                    }
                } else {
                    requestAnimationFrame(scanFrame);
                }
            }
            
            scanFrame();
        }

        function stopCameraScanner() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            
            document.getElementById('scanner-container').style.display = 'none';
            updateStatus('‚úÖ Sistem gata pentru scanare - ApasƒÉ unul din butoanele de scanare pentru a √Æncepe', 'ready');
        }

        function switchCamera() {
            if (mediaStream) {
                currentCamera = currentCamera === 'environment' ? 'user' : 'environment';
                stopCameraScanner();
                setTimeout(startCameraScanner, 100);
            }
        }

        // Expose functions for global use
        window.sendToGoogleSheets = sendToGoogleSheets;
        window.simulateGoogleSheetsUpload = simulateGoogleSheetsUpload;
    </script>
</body>
</html>